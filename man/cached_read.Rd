% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cached_read.R
\name{cached_read}
\alias{cached_read}
\alias{cached_read_csv}
\alias{use_caching}
\title{Read data and save to a local "cache" file.}
\usage{
cached_read(
  files,
  read_fn,
  cache_type = NULL,
  label = "data",
  cache_dir = NULL,
  check = "file_info",
  write_cache_fn = NULL,
  read_cache_fn = NULL,
  cache_ext = NULL
)

cached_read_csv(
  files,
  cache_type = NULL,
  write_cache_fn = NULL,
  read_cache_fn = NULL,
  label = "data",
  cache_dir = NULL,
  check = "file_info",
  ...
)

use_caching(
  expr,
  cache_type = NULL,
  label = "data",
  cache_dir = NULL,
  check = "exists",
  write_cache_fn = NULL,
  read_cache_fn = NULL,
  cache_ext = NULL
)
}
\arguments{
\item{files}{A vector of path(s) to file(s). This will be passed as the first argument to \code{read_fn}.}

\item{read_fn}{A function that can read \code{files} into a data frame.
This can be one of three options:
\enumerate{
\item Standard function object, e.g. \code{readr::read_csv}
\item An anonymous function that takes \code{files}, e.g.
\itemize{
\item \verb{\\(files) readr::read_csv(files, skip = 2) |> janitor::clean_names()}
}
}

To use multiple files with a function that only takes a single file, use \code{lapply} and \code{dplyr::bind_rows} or \code{purrr::map} and \code{purr::list_rbind}, e.g.

\if{html}{\out{<div class="sourceCode">}}\preformatted{ \\(files) lapply(files, data.table::fread) |> dplyr::bind_rows()
 \\(files) purrr::map(files, data.table::fread) |> purrr::list_rbind()
}\if{html}{\out{</div>}}}

\item{cache_type}{The type of file to use for caching.
This can be one of two options:
\enumerate{
\item One of the following strings:
\itemize{
\item "arrow" to use \verb{arrow::<read|write>_feather},
\item "data.table" to use \verb{data.table::f<read|write>},
\item "csv" to use the first available of \verb{arrow::<read|write>_csv}, \code{readr}, \code{data.table}, or base R \code{utils}.
}
\item NULL:
\itemize{
\item (Default) Uses "arrow" if installed, otherwise "csv".
\item Uses \code{write_cache_fn}, \code{read_cache_fn}, and \code{cache_ext} if provided.
}
}}

\item{label}{The label to give the cached file,
e.g. generating a file with the path 'data.fused_arrow'.}

\item{cache_dir}{Path to the folder that will contain the cache file.
If NULL (default), uses the common path among the inputs, as determined by \code{fs::path_common}.}

\item{check}{Determines when to re-read from the original sources. This can be one of the following options:
\enumerate{
\item (default) "file_info": Stores file metadata and re-reads if there have been any changes.
\item "exists": Checks whether the cache file exists in the \code{cache_dir} with the indicated label.
\item "force": Does not do any checking and simply re-builds the cache file.
}}

\item{write_cache_fn, read_cache_fn}{Functions used to write and read the cache file. To use this option,
\code{cache_type} must be NULL, both functions must be provided, and \code{cache_ext} cannot be null..}

\item{cache_ext}{The extension to use on the cache file if \code{write_cache_fn} and \code{read_cache_fn} are provided.}

\item{...}{Arguments passed on to \code{readr::read_csv} (if installed) or \code{utils::read.csv}.}

\item{expr}{Expression that generates a tibble, typically reading from files.}
}
\value{
A \code{tibble}. Results are coerced to a tibble regardless of read_fn or cache_type to ensure uniformity and predictability of output type.
}
\description{
Read data and save to a local "cache" file for easier management and re-reading.

If no cache file already exists, performs the desired read operation and writes the results to a cache file. Optionally, also saves a cache file containing the latest file update info.
If the cache file exists, it is read instead. By default it also tracks for file updating so that the file(s) are
re-read from scratch if they have changed.

The type of cache file used depends on the \code{cache_type} parameter and the packages installed.
We recommend installing the \code{arrow} package, which allows use writing and reading into an Arrow IPC format.
}
\details{
\subsection{\code{cached_read}}{

This the most flexible version. By default (\code{check = "file_info"}), it checks whether
the original files have been modified (using \code{fs::file_info}) and therefore whether the results should be
re-read from the original files or from the cache file.

When reading from a slow file system, even getting the file information can be slow; in this case, we
recommend \code{check = "exists"} to only check whether the cache exists.

e.g.

\if{html}{\out{<div class="sourceCode">}}\preformatted{cached_read(some_files, arrow::read_feather)
}\if{html}{\out{</div>}}

to read from a set of arrow feather files.
}

\subsection{\code{cached_read_csv}}{

This is like \code{cached_read} but uses the first read csv function available between \code{arrow},
\code{readr}, \code{data.table}, or base R \code{utils}.
}

\subsection{\code{use_caching}}{

Unlike \code{cached_read}, this can be piped at the end of an existing data pipeline, making it easy
to integrate temporarily, if desired. However, because it does not have direct access to the file
list, it cannot use \code{check = "file_info"}.

e.g.

\if{html}{\out{<div class="sourceCode">}}\preformatted{readr::read_csv(some_files) |>
  janitor::clean_names() |>
  dplyr::summarize(...) |>
  use_caching()
}\if{html}{\out{</div>}}
}
}
\examples{
\dontrun{


# Standard read method
res <- some_files |>
  readr::read_csv() |>
  janitor::clean_names()

# With caching there's now a single file that can be re-read more quickly in the future.
res <- some_files |>
  cached_read(
    \(file) readr::read_csv(file)
      |> janitor::clean_names()
  )

res <- some_files |>
  readr::read_csv() |>
  janitor::clean_names() |>
  use_caching()

}
}
